// DO NOT EDIT
// Generated by JFlex 1.9.1 http://jflex.de/
// source: src/commonMain/kotlin/org/intellij/markdown/flavours/custom/lexer/custom.flex
package org.intellij.markdown.flavours.custom.lexer

import org.intellij.markdown.IElementType
import org.intellij.markdown.MarkdownTokenTypes
import org.intellij.markdown.flavours.custom.CustomTokenTypes
import org.intellij.markdown.lexer.Compat
import org.intellij.markdown.lexer.GeneratedLexer

class _CustomLexer : GeneratedLexer {
    /** the current lexical state  */
    override var state = YYINITIAL
        private set

    /** startRead marks the beginning of the yytext() string in the buffer  */
    override var tokenStart = 0
        private set

    override val tokenEnd: Int
        get() = tokenStart + yylength()

    override fun reset(buffer: CharSequence, start: Int, end: Int, initialState: Int) {
        zzBuffer = buffer
        tokenStart = start
        zzMarkedPos = tokenStart
        zzCurrentPos = zzMarkedPos
        zzAtEOF = false
        zzAtBOL = true
        zzEndRead = end
        yybegin(initialState)
    }

    /** Current state of the DFA.  */
    private var zzState = 0

    /** Current lexical state.  */
    private var zzLexicalState = YYINITIAL

    /**
     * This buffer contains the current text to be matched and is the source of the [.yytext]
     * string.
     */
    private var zzBuffer: CharSequence = ""

    /** Text position at the last accepting state.  */
    private var zzMarkedPos = 0

    /** Current text position in the buffer.  */
    private var zzCurrentPos = 0

    /** Marks the beginning of the [.yytext] string in the buffer.  */
    private var zzStartRead = 0

    /** Marks the last character in the buffer, that has been read from input.  */
    private var zzEndRead = 0

    /**
     * Whether the scanner is at the end of file.
     * @see .yyatEOF
     */
    private var zzAtEOF = false

    /**
     * The number of occupied positions in [.zzBuffer] beyond [.zzEndRead].
     *
     *
     * When a lead/high surrogate has been read from the input stream into the final
     * [.zzBuffer] position, this will have a value of 1; otherwise, it will have a value of 0.
     */
    private var zzFinalHighSurrogate = 0

    /** Number of newlines encountered up to the start of the matched text.  */
    @Suppress("unused")
    private var yyline = 0

    /** Number of characters from the last newline up to the start of the matched text.  */
    @Suppress("unused")
    private var yycolumn = 0

    /** Number of characters up to the start of the matched text.  */
    @Suppress("unused")
    private var yychar: Long = 0

    /** Whether the scanner is currently at the beginning of a line.  */
    @Suppress("unused")
    private var zzAtBOL = true

    /** Whether the user-EOF-code has already been executed.  */
    @Suppress("unused")
    private var zzEOFDone = false

    /** Returns the maximum size of the scanner buffer, which limits the size of tokens.  */
    private fun zzMaxBufferLen(): Int {
        return Int.MAX_VALUE
    }

    /**  Whether the scanner buffer can grow to accommodate a larger token.  */
    private fun zzCanGrow(): Boolean {
        return true
    }

    /**
     * Refills the input buffer.
     *
     * @return `false` iff there was new input.
     * @exception java.io.IOException  if any I/O-Error occurs
     */
    private fun zzRefill(): Boolean = true


    /**
     * Resets the input position.
     */
    private fun yyResetPosition() {
        zzAtBOL = true
        zzAtEOF = false
        zzCurrentPos = 0
        zzMarkedPos = 0
        zzStartRead = 0
        zzEndRead = 0
        zzFinalHighSurrogate = 0
        yyline = 0
        yycolumn = 0
        yychar = 0L
    }


    /**
     * Returns whether the scanner has reached the end of the reader it reads from.
     *
     * @return whether the scanner has reached EOF.
     */
    fun yyatEOF(): Boolean {
        return zzAtEOF
    }


    /**
     * Returns the current lexical state.
     *
     * @return the current lexical state.
     */
    fun yystate(): Int {
        return zzLexicalState
    }


    /**
     * Enters a new lexical state.
     *
     * @param newState the new lexical state
     */
    fun yybegin(newState: Int) {
        zzLexicalState = newState
    }


    /**
     * Returns the text matched by the current regular expression.
     *
     * @return the matched text.
     */
    fun yytext(): CharSequence {
        return zzBuffer.subSequence(tokenStart, zzMarkedPos)
    }


    /**
     * Returns the character at the given position from the matched text.
     *
     *
     * It is equivalent to `yytext().charAt(pos)`, but faster.
     *
     * @param position the position of the character to fetch. A value from 0 to `yylength()-1`.
     *
     * @return the character at `position`.
     */
    fun yycharat(position: Int): Char {
        return zzBuffer[zzStartRead + position]
    }


    /**
     * How many characters were matched.
     *
     * @return the length of the matched text region.
     */
    fun yylength(): Int {
        return zzMarkedPos - zzStartRead
    }


    /**
     * Pushes the specified amount of characters back into the input stream.
     *
     *
     * They will be read again by then next call of the scanning method.
     *
     * @param number the number of characters to be read again. This number must not be greater than
     * [.yylength].
     */
    fun yypushback(number: Int) {
        if (number > yylength()) zzScanError(ZZ_PUSHBACK_2BIG)

        zzMarkedPos -= number
    }


    /**
     * Resumes scanning until the next regular expression is matched, the end of input is encountered
     * or an I/O-Error occurs.
     *
     * @return the next token.
     * @exception java.io.IOException if any I/O-Error occurs.
     */
    override fun advance(): IElementType? {
        var zzInput: Int
        var zzAction: Int

        // cached fields:
        var zzCurrentPosL: Int
        var zzMarkedPosL: Int
        var zzEndReadL = zzEndRead
        var zzBufferL = zzBuffer

        val zzTransL = ZZ_TRANS
        val zzRowMapL = ZZ_ROWMAP
        val zzAttrL = ZZ_ATTRIBUTE

        while (true) {
            zzMarkedPosL = zzMarkedPos

            zzAction = -1

            tokenStart = zzMarkedPosL
            zzStartRead = zzMarkedPosL
            zzCurrentPos = zzStartRead
            zzCurrentPosL = zzCurrentPos

            zzState = ZZ_LEXSTATE[zzLexicalState]

            // set up zzAction for empty match case:
            var zzAttributes = zzAttrL[zzState]
            if ((zzAttributes and 1) == 1) {
                zzAction = zzState
            }


            zzForAction@
            while (true) {
                if (zzCurrentPosL < zzEndReadL) {
                    zzInput = Compat.codePointAt(zzBufferL, zzCurrentPosL /*, zzEndReadL*/)
                    zzCurrentPosL += Compat.charCount(zzInput)
                } else if (zzAtEOF) {
                    zzInput = YYEOF
                    break@zzForAction
                } else {
                    // store back cached positions
                    zzCurrentPos = zzCurrentPosL
                    zzMarkedPos = zzMarkedPosL
                    val eof = zzRefill()
                    // get translated positions and possibly new buffer
                    zzCurrentPosL = zzCurrentPos
                    zzMarkedPosL = zzMarkedPos
                    zzBufferL = zzBuffer
                    zzEndReadL = zzEndRead
                    if (eof) {
                        zzInput = YYEOF
                        break@zzForAction
                    } else {
                        zzInput = Compat.codePointAt(zzBufferL, zzCurrentPosL /*, zzEndReadL*/)
                        zzCurrentPosL += Compat.charCount(zzInput)
                    }
                }
                val zzNext = zzTransL[zzRowMapL[zzState] + zzCMap(
                    zzInput
                )]
                if (zzNext == -1) break@zzForAction
                zzState = zzNext

                zzAttributes = zzAttrL[zzState]
                if ((zzAttributes and 1) == 1) {
                    zzAction = zzState
                    zzMarkedPosL = zzCurrentPosL
                    if ((zzAttributes and 8) == 8) break@zzForAction
                }
            }


            // store back cached position
            zzMarkedPos = zzMarkedPosL

            if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
                zzAtEOF = true
                return null
            } else {
                when (if (zzAction < 0) zzAction else ZZ_ACTION[zzAction]) {
                    1 -> {
                        return MarkdownTokenTypes.TEXT
                    }

                    8 -> {}
                    2 -> {
                        return CustomTokenTypes.WHITE_SPACE
                    }

                    9 -> {}
                    3 -> {
                        yypushback(1)
                        return MarkdownTokenTypes.HARD_LINE_BREAK
                    }

                    10 -> {}
                    4 -> {
                        return CustomTokenTypes.STRONG_MARKER
                    }

                    11 -> {}
                    5 -> {
                        return CustomTokenTypes.UNDERLINE_MARKER
                    }

                    12 -> {}
                    6 -> {
                        return CustomTokenTypes.ITALIC_MARKER
                    }

                    13 -> {}
                    7 -> {
                        return CustomTokenTypes.STRIKETHROUGH_MARKER
                    }

                    14 -> {}
                    else -> zzScanError(ZZ_NO_MATCH)
                }
            }
        }
    }


    companion object {
        /** This character denotes the end of file.  */
        const val YYEOF: Int = -1

        /** Initial size of the lookahead buffer.  */
        private const val ZZ_BUFFERSIZE = 16384

        // Lexical states.
        const val YYINITIAL: Int = 0

        /**
         * ZZ_LEXSTATE[l] is the state in the DFA for the lexical state l
         * ZZ_LEXSTATE[l+1] is the state in the DFA for the lexical state l
         * at the beginning of a line
         * l is of the form l = 2*k, k a non negative integer
         */
        private val ZZ_LEXSTATE = intArrayOf(
            0, 0
        )

        /**
         * Top-level table for translating characters to character classes
         */
        private val ZZ_CMAP_TOP = zzUnpackcmap_top()

        private const val ZZ_CMAP_TOP_PACKED_0 = "\u0001\u0000\u001f\u0100\u0001\u0200\u10df\u0100"

        private fun zzUnpackcmap_top(): IntArray {
            val result = IntArray(4352)
            var offset = 0
            offset = zzUnpackcmap_top(ZZ_CMAP_TOP_PACKED_0, offset, result)
            return result
        }

        private fun zzUnpackcmap_top(packed: String, offset: Int, result: IntArray): Int {
            var i = 0 /* index in packed string  */
            var j = offset /* index in unpacked array */
            val l = packed.length
            while (i < l) {
                var count = packed[i++].code
                val value = packed[i++].code
                do result[j++] = value while (--count > 0)
            }
            return j
        }


        /**
         * Second-level tables for translating characters to character classes
         */
        private val ZZ_CMAP_BLOCKS = zzUnpackcmap_blocks()

        private const val ZZ_CMAP_BLOCKS_PACKED_0 =
            "\u0009\u0000\u0001\u0001\u0001\u0002\u0001\u0003\u0001\u0004\u0001\u0005\u0012\u0000\u0001\u0001" +
                    "\u0009\u0000\u0001\u0006\u0001\u0007\u0030\u0000\u0001\u0008\u0002\u0000\u0001\u0009\u001e\u0000" +
                    "\u0001\u000a\u0006\u0000\u0001\u0003\u01a2\u0000\u0002\u0003\u00d6\u0000"

        private fun zzUnpackcmap_blocks(): IntArray {
            val result = IntArray(768)
            var offset = 0
            offset = zzUnpackcmap_blocks(ZZ_CMAP_BLOCKS_PACKED_0, offset, result)
            return result
        }

        private fun zzUnpackcmap_blocks(packed: String, offset: Int, result: IntArray): Int {
            var i = 0 /* index in packed string  */
            var j = offset /* index in unpacked array */
            val l = packed.length
            while (i < l) {
                var count = packed[i++].code
                val value = packed[i++].code
                do result[j++] = value while (--count > 0)
            }
            return j
        }

        /**
         * Translates DFA states to action switch labels.
         */
        private val ZZ_ACTION = zzUnpackAction()

        private const val ZZ_ACTION_PACKED_0 =
            "\u0001\u0000\u0001\u0001\u0001\u0002\u0001\u0000\u0001\u0001\u0001\u0002\u0001\u0000\u0005\u0001" +
                    "\u0003\u0003\u0001\u0004\u0001\u0005\u0001\u0006\u0001\u0007"

        private fun zzUnpackAction(): IntArray {
            val result = IntArray(19)
            var offset = 0
            offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result)
            return result
        }

        private fun zzUnpackAction(packed: String, offset: Int, result: IntArray): Int {
            var i = 0 /* index in packed string  */
            var j = offset /* index in unpacked array */
            val l = packed.length
            while (i < l) {
                var count = packed[i++].code
                val value = packed[i++].code
                do result[j++] = value while (--count > 0)
            }
            return j
        }


        /**
         * Translates a state to a row index in the transition table
         */
        private val ZZ_ROWMAP = zzUnpackRowMap()

        private const val ZZ_ROWMAP_PACKED_0 =
            "\u0000\u0000\u0000\u000b\u0000\u0016\u0000\u0021\u0000\u0021\u0000\u002c\u0000\u0037\u0000\u0042" +
                    "\u0000\u004d\u0000\u0058\u0000\u0063\u0000\u006e\u0000\u000b\u0000\u0021\u0000\u002c\u0000\u000b" +
                    "\u0000\u000b\u0000\u000b\u0000\u000b"

        private fun zzUnpackRowMap(): IntArray {
            val result = IntArray(19)
            var offset = 0
            offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result)
            return result
        }

        private fun zzUnpackRowMap(packed: String, offset: Int, result: IntArray): Int {
            var i = 0 /* index in packed string  */
            var j = offset /* index in unpacked array */
            val l = packed.length - 1
            while (i < l) {
                val high = packed[i++].code shl 16
                result[j++] = high or packed[i++].code
            }
            return j
        }

        /**
         * The transition table of the DFA
         */
        private val ZZ_TRANS = zzUnpacktrans()

        private const val ZZ_TRANS_PACKED_0 =
            "\u0001\u0002\u0001\u0003\u0001\u0004\u0001\u0005\u0001\u0006\u0001\u0007\u0001\u0008\u0001\u0009" +
                    "\u0001\u000a\u0001\u000b\u0001\u000c\u000c\u0000\u0001\u0003\u0002\u0004\u0001\u0006\u0001\u0007" +
                    "\u0005\u0000\u0001\u000d\u0001\u000e\u0001\u0000\u0001\u000d\u0001\u000e\u0001\u0000\u0006\u000d" +
                    "\u0001\u000f\u0001\u0004\u0001\u000e\u0001\u000f\u0001\u0007\u0006\u000d\u0001\u000e\u0001\u0004" +
                    "\u0001\u000d\u0001\u000e\u0001\u0000\u0005\u000d\u0006\u0000\u0001\u0010\u000b\u0000\u0001\u0011" +
                    "\u0009\u0000\u0002\u0002\u0001\u0000\u0002\u0002\u0009\u0000\u0001\u0012\u000b\u0000\u0001\u0013"

        private fun zzUnpacktrans(): IntArray {
            val result = IntArray(121)
            var offset = 0
            offset = zzUnpacktrans(ZZ_TRANS_PACKED_0, offset, result)
            return result
        }

        private fun zzUnpacktrans(packed: String, offset: Int, result: IntArray): Int {
            var i = 0 /* index in packed string  */
            var j = offset /* index in unpacked array */
            val l = packed.length
            while (i < l) {
                var count = packed[i++].code
                var value = packed[i++].code
                value--
                do result[j++] = value while (--count > 0)
            }
            return j
        }


        /** Error code for "Unknown internal scanner error".  */
        private const val ZZ_UNKNOWN_ERROR = 0

        /** Error code for "could not match input".  */
        private const val ZZ_NO_MATCH = 1

        /** Error code for "pushback value was too large".  */
        private const val ZZ_PUSHBACK_2BIG = 2

        /**
         * Error messages for [.ZZ_UNKNOWN_ERROR], [.ZZ_NO_MATCH], and
         * [.ZZ_PUSHBACK_2BIG] respectively.
         */
        private val ZZ_ERROR_MSG = arrayOf(
            "Unknown internal scanner error",
            "Error: could not match input",
            "Error: pushback value was too large"
        )

        /**
         * ZZ_ATTRIBUTE[aState] contains the attributes of state `aState`
         */
        private val ZZ_ATTRIBUTE = zzUnpackAttribute()

        private const val ZZ_ATTRIBUTE_PACKED_0 =
            "\u0001\u0000\u0001\u0009\u0001\u0001\u0001\u0000\u0002\u0001\u0001\u0000\u0005\u0001\u0001\u0009" +
                    "\u0002\u0001\u0004\u0009"

        private fun zzUnpackAttribute(): IntArray {
            val result = IntArray(19)
            var offset = 0
            offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result)
            return result
        }

        private fun zzUnpackAttribute(packed: String, offset: Int, result: IntArray): Int {
            var i = 0 /* index in packed string  */
            var j = offset /* index in unpacked array */
            val l = packed.length
            while (i < l) {
                var count = packed[i++].code
                val value = packed[i++].code
                do result[j++] = value while (--count > 0)
            }
            return j
        }

        /**
         * Translates raw input code points to DFA table row
         */
        private fun zzCMap(input: Int): Int {
            val offset = input and 255
            return if (offset == input) ZZ_CMAP_BLOCKS[offset] else ZZ_CMAP_BLOCKS[ZZ_CMAP_TOP[input shr 8] or offset]
        }

        /**
         * Reports an error that occurred while scanning.
         *
         *
         * In a well-formed scanner (no or only correct usage of `yypushback(int)` and a
         * match-all fallback rule) this method will only be called with things that
         * "Can't Possibly Happen".
         *
         *
         * If this method is called, something is seriously wrong (e.g. a JFlex bug producing a faulty
         * scanner etc.).
         *
         *
         * Usual syntax/scanner level error handling should be done in error fallback rules.
         *
         * @param errorCode the code of the error message to display.
         */
        private fun zzScanError(errorCode: Int) {
            var message = try {
                ZZ_ERROR_MSG[errorCode]
            } catch (e: RuntimeException) {
                ZZ_ERROR_MSG[ZZ_UNKNOWN_ERROR]
            }

            throw Error(message)
        }
    }
}
